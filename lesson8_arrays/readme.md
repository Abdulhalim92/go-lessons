### Что такое массивы
    Массив (array) — это коллекция фиксированной длины, содержащая элементы одного типа. 
    Длина массива определяется при его создании и не может быть изменена. Элементы 
    массива могут быть любого типа, включая другие массивы и структуры.
```go
var arr [5]int // массив из 5 целых чисел, по умолчанию заполнен нулями
```

### Создание массива
    Создание массива может включать или не включать инициализацию значений:
- Пустой массив:
```go
var arr [5]int // массив из 5 целых чисел, по умолчанию заполнен нулями
```

- Инициализация массива с начальными значениями:
```go
arr2 := [3]string{"a", "b", "c"}

```

- Автоматическое определение длины массива:
```go
arr3 := [...]int{1, 2, 3, 4, 5}
```

- Многомерные массивы:
```go
var matrix [3][4]int // матрица 3x4, массив массивов
```

### Ключи (индексы) массивов
    Индексы массива начинаются с 0 и идут до len(arr)-1. Попытка доступа к индексу вне
    этого диапазона вызовет ошибку времени выполнения.
```go
value := arr[0]  // доступ к первому элементу
arr[4] = 10      // изменение пятого элемента
// arr[5] = 10   // ошибка, индекс вне диапазона
```

### Получение и изменение элементов по индексу
    Для доступа к элементу массива по индексу используется синтаксис array[index].
```go
value := arr[0]  // получение значения первого элемента
arr[1] = 10      // изменение значения второго элемента
```

### Длина (len) и вместимость (cap) массива
    Длина массива - это количество элементов в массиве. Вместимость - это максимальное
    количество элементов, которое может содержать массив. При изменении длины массива
    Для массива длина и вместимость всегда равны и могут быть получены с помощью 
    функций len и cap.
```go
length := len(arr) // длина массива
capacity := cap(arr) // вместимость массива
```

### Итерация по массиву
    Итерация по массиву осуществляется с помощью цикла for:
```go
for i := 0; i < len(arr); i++ {
    fmt.Println(arr[i])
}

// или с использованием конструкции for range:
for i, v := range arr {
    fmt.Println(i, v)
}
```

### Что такое срез
    Срез (slice) — это динамическая последовательность элементов одного типа, длина и 
    вместимость которой могут изменяться. Срезы являются ссылочными типами и ссылаются 
    на массивы. В отличие от массивов, срезы более гибкие и их длина может изменяться.
```go
slice := []int{1, 2, 3}
```

### Создание слайса
    Срезы можно создавать несколькими способами:
- На основе массива:
```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // срез содержит элементы со 2-го по 4-й (индексы 1, 2, 3)
```

- С помощью литерала:
```go
slice := []int{1, 2, 3}
```

- Пустой срез:
```go
var emptySlice []int
```

### Длина и вместимость слайса
    Длина среза (len) — это количество элементов в срезе. Вместимость (cap) — это количество 
    элементов, которые могут быть помещены в срез без выделения новой памяти.
```go
slice := []int{1, 2, 3, 4, 5}
fmt.Println(len(slice)) // 5
fmt.Println(cap(slice)) // 5
```

### Создание слайса через make
    Срезы можно создавать с помощью функции make:
```go
slice := make([]int, 5) // создание среза длиной 5 и вместимостью 5
slice2 := make([]int, 5, 10) // создание среза длиной 5 и вместимостью 10
```

### Функция append
    Функция append добавляет новые элементы в конец среза и возвращает новый срез. 
    Если вместимость среза недостаточна, append выделяет новый массив, копирует в него
    старые элементы и добавляет новые.
```go
slice := []int{1, 2, 3}
slice = append(slice, 4, 5) // добавление элементов 4 и 5
```

### Конкатенация срезов
    Конкатенация срезов — это добавление двух или более срезов в один срез. 
    Конкатенация срезов возвращает новый срез. Если вместимость среза недостаточна,
    конкатенация выделяет новый массив, копирует в него старые элементы и добавляет
    новые.
```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5}
slice3 := append(slice1, slice2...) // добавление среза slice2 в срез slice1
```

### Операция слайсинг (создание среза на основе массива или слайса)
    Создание среза на основе массива или другого среза можно выполнить с использованием
    синтаксиса slice[start:end]. Начальный индекс включается, конечный — нет.
```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // срез содержит элементы со 2-го по 4-й (индексы 1, 2, 3)
fmt.Println(slice) // [2 3 4]

slice2 := slice[1:2] // срез на основе другого среза
fmt.Println(slice2) // [3]
```

### Функция copy
    Функция copy копирует элементы из одного среза в другой и возвращает количество
    скопированных элементов. Целевой срез должен иметь достаточную длину для 
    размещения копируемых элементов.
```go
src := []int{1, 2, 3}
dst := make([]int, len(src))
n := copy(dst, src) // копирование всех элементов из src в dst
fmt.Println(dst) // [1 2 3]
fmt.Println(n) // 3
```

# Дополнительные аспекты массивов

### Инициализация массива с использованием ключей (индексов)
    Можно инициализировать массив, указывая значения для определённых индексов:
```go
arr := [5]int{0: 10, 4: 20} // массив, где первый элемент равен 10, а пятый - 20
```

### Копирование массива
    В отличие от срезов, при присваивании одного массива другому происходит 
    копирование значений:
```go
arr1 := [3]int{1, 2, 3}
arr2 := arr1 // копирование значений
arr2[0] = 10
fmt.Println(arr1) // [1 2 3]
fmt.Println(arr2) // [10 2 3]
```

# Дополнительные аспекты срезов

### Срезы и память
    Срезы являются ссылками на память, поэтому изменения в одном срезе влияют на
    другие.
    Срезы занимают три поля в памяти:
- указатель на начало среза
- длина среза
- вместимость среза
```go
slice := []int{1, 2, 3, 4, 5}
slice2 := slice[1:3] // длина 2, вместимость 4
fmt.Println(len(slice2), cap(slice2)) // 2 4
```

### Изменение среза изменяет исходный массив
    Поскольку срезы ссылаются на массив, изменение среза изменяет массив:
```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4]
slice[0] = 10
fmt.Println(arr) // [1 10 3 4 5]
```

### Nil срезы
    Nil срезы эквивалентны пустым срезам, но у них нулевая длина и вместимость:
```go
var nilSlice []int
fmt.Println(nilSlice == nil) // true
fmt.Println(len(nilSlice), cap(nilSlice)) // 0 0
```

### Срез с максимальной вместимостью
    Срез можно создать с указанием максимальной вместимости:
```go
arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:3:4] // длина 2, вместимость 3
fmt.Println(len(slice), cap(slice)) // 2 3
```


### Удаление элемента из среза
    Удаление элемента из среза требует создания нового среза:
```go
slice := []int{1, 2, 3, 4, 5}
index := 2 // индекс элемента для удаления
slice = append(slice[:index], slice[index+1:]...)
fmt.Println(slice) // [1 2 4 5]
```

### Вставка элемента в срез
    Для вставки элемента в срез требуется создание нового среза:
```go
slice := []int{1, 2, 3, 5}
index := 3 // индекс для вставки
value := 4
slice = append(slice[:index], append([]int{value}, slice[index:]...)...)
fmt.Println(slice) // [1 2 3 4 5]
```

### Общая формула вычисления ёмкости среза
    Если используется синтаксис с тремя параметрами arr[low:high:max], то ёмкость вычисляется как:
    capacity =  max  −  low

    Если используется синтаксис с двумя параметрами arr[low:high], то ёмкость вычисляется как:
    capacity=len(arr)−low

### Общая формула вычисления ёмкости для пустого среза
    Если пустой срез создается с использованием функции make с заданной ёмкостью, то ёмкость
    среза равна указанному значению. Если ёмкость не указана, то по умолчанию она равна 0.

    Примеры:
    - make([]int, 0, 10) — ёмкость 10.
    - var slice []int — ёмкость 0.
    - []int{} — ёмкость 0.

### Алгоритм увеличения ёмкости
    Go использует алгоритм для увеличения ёмкости среза, который стремится минимизировать количество
    выделений памяти. Обычно ёмкость увеличивается следующим образом:
- Если ёмкость среза была 0, то она увеличивается до 1.
- Если ёмкость среза была ненулевая, то она обычно удваивается (Для маленьких срезов до ёмкости 1024 элементов).
- Для больших срезов (с ёмкостью более 1024 элементов) ёмкость увеличивается на примерно 25% при каждом добавлении.
